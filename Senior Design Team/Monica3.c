#pragma config(Sensor, dgtl12, killtower,      sensorTouch)
#pragma config(Sensor, dgtl11,  solenoid,       sensorDigitalOut)
#pragma config(Motor,  port1,           lift_M5,       tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           drive_M2,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           drive_M3,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           drive_M4,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           drive_M1,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           lift_M10,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift_M6,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lift_M9,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           claw,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          lift_M7,       tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define max(x, y) (((x) > (y)) ? (x) : (y))

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


void liftControl();
void driveControl();
void clawControl();

bool open = true;
bool prev_btn = false;

void pre_auton() {
	bStopTasksBetweenModes = true;
}
task autonomous() {
}

task usercontrol() {
	// ALL USER CONTROL CODE MUST GO INSIDE THE LOOP


while (true) {

		liftControl();
		driveControl();
		clawControl();
		wait1Msec(100);

	}
}

/// Begin User Defined Functions

// Drive Control, channel 1 rotates; channel 3 drives; channel 4 strafes
void driveControl() {
	motor[drive_M1] = ( vexRT[Ch1] - vexRT[Ch3] + vexRT[Ch4]);
	motor[drive_M2] = ( vexRT[Ch1] + vexRT[Ch3] + vexRT[Ch4]);
	motor[drive_M4] = (-vexRT[Ch1] + vexRT[Ch3] + vexRT[Ch4]);
	motor[drive_M3] = (-vexRT[Ch1] - vexRT[Ch3] + vexRT[Ch4]);
}

void liftControl() {

	if (vexRT[Btn6U]) {
		motor[lift_M5] = 120;
		motor[lift_M7] = 120;
		motor[lift_M10] = 120;
		motor[lift_M6] = 120;
		motor[lift_M9] = 120;
			}
	else if (vexRT[Btn6D]) {
		motor[lift_M5] = -120;
		motor[lift_M7] = -120;
		motor[lift_M10] = -120;
		motor[lift_M6] = -120;
		motor[lift_M9] = -120;
	}
	else {
		motor[lift_M5] = 0;
		motor[lift_M7] = 0;
		motor[lift_M10] = 0;
		motor[lift_M6] = 0;
		motor[lift_M9] = 0;
	}

	clearDebugStream();
	if (SensorValue[killtower])
	{
			writeDebugStreamLine("Detected sensor");
	}

	if (SensorValue[killtower])
	{
			int motors[5] = {lift_M5, lift_M7, lift_M10, lift_M6, lift_M9};

			for (int i = 0; i < 5; i++)
			{
					int m = motors[i];
					motor[m] = max(motor[m], 0);
			}

			writeDebugStreamLine("Controlled Effort: %d", motor[lift_M5]);
	}

}
void clawControl() {

		if (vexRT[Btn5U] && !prev_btn)
		{
				open = !open;
		}

		if(open)         // If button 6U (upper right shoulder button) is pressed:
		{
      	SensorValue[solenoid] = 1;  // ...activate the solenoid.
		}
		else
		{
				SensorValue[solenoid] = 0;
		}

		prev_btn = (bool) vexRT[Btn5U];
}
