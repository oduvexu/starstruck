#pragma config(Sensor, dgtl11, solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl12, killtower,      sensorTouch)
#pragma config(Motor,  port2,  LIFT_BOTTOM_RIGHT, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,  LIFT_TOP_RIGHT, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  A_Drive_LM,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,  B_Drive_L,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,  C_Drive_R,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,  D_Drive_RM,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,  LIFT_TOP_LEFT, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,  LIFT_BOTTOM_LEFT, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 60 seconds of recording, 10 records per second.
#define MAX_RECORD_SIZE 600

// Defines the exact time the values in a specific index were recorded.
// Used to match the play-back behavior in terms of recorded time, rather
// than a specific time-delta based on index.
float record_time[MAX_RECORD_SIZE];

// Defines the base effort to apply over time.
signed char L_effort[MAX_RECORD_SIZE];
signed char R_effort[MAX_RECORD_SIZE];
signed char T_effort[MAX_RECORD_SIZE];

// Defines the cumulative encoder position targets to aim for, over time.
// Used to apply a modifier to the base effort, linearly proportional to
// the delta between the target encoder position and the current encoder.
signed int L_target[MAX_RECORD_SIZE];
signed int R_target[MAX_RECORD_SIZE];
signed int T_target[MAX_RECORD_SIZE];

// Defined by sizeof(vexRT)/4
#define NUM_OF_BUTTONS 22
bool _vexRT[NUM_OF_BUTTONS];

unsigned int record_length = 0;
unsigned int seek_index = 0;

bool open = false;

enum _modeType {NORMAL, RECORD_WAIT, RECORDING, PLAYBACK};
enum _modeType mode = NORMAL;

void updateButtons()
{
	for (int i = 0; i < NUM_OF_BUTTONS; i++)
	{
		_vexRT[i] = (bool) vexRT[i];
	}
}

task main()
{
	clearDebugStream();
	writeDebugStream("Record/Playback Demo Program Start\n");

	writeDebugStream("Size of nSysTime is %d\n", sizeof(nSysTime));

	while (true)
	{
		if (mode == NORMAL)
		{
			int effort_L = vexRT[Ch3] + vexRT[Ch1];
			int effort_R = vexRT[Ch3] - vexRT[Ch1];

			effort_L = effort_L < -127 ? -127 : (effort_L > 127 ? 127 : effort_L);
			effort_R = effort_R < -127 ? -127 : (effort_R > 127 ? 127 : effort_R);

			int effort_T = 120*(vexRT[Btn6U] ? 1 : -vexRT[Btn6D]);

			delay(100);

			writeDebugStream("State of button: %d\n", vexRT[Btn5U] && !_vexRT[Btn5U]);

			if (vexRT[Btn5U] && !_vexRT[Btn5U])
			{
				open = !open;
				writeDebugStream("Solenoid change\n");
			}

			SensorValue[solenoid] = open;

			writeDebugStream("State of solenoid:%d  %d\n", open, SensorValue[solenoid]);

			motor[LIFT_BOTTOM_LEFT] = effort_T;
			motor[LIFT_TOP_LEFT] = effort_T;
			motor[LIFT_BOTTOM_RIGHT] = effort_T;
			motor[LIFT_TOP_RIGHT] = effort_T;

			motor[A_Drive_LM] = effort_L;
			motor[B_Drive_L] =  effort_L;
			motor[C_Drive_R] =  effort_R;
			motor[D_Drive_RM] = effort_R;

			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				// Transition to record wait state.
				mode = RECORD_WAIT;
				writeDebugStream("Transitioned to RECORD_WAIT mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			if (record_length != 0)
			{
				if (vexRT[Btn8R] && !_vexRT[Btn8R])
				{
					// Transition to playback state.
					mode = PLAYBACK;
					writeDebugStream("Transitioned to PLAYBACK mode at t = %f\n", (float) nSysTime / 1000.0);

					seek_index = 0;
					nMotorEncoder[B_Drive_L] = 0;
					nMotorEncoder[C_Drive_R] = 0;
					nMotorEncoder[LIFT_TOP_LEFT] = 0;
					clearTimer(T1);
					datalogClear();
				}
			}
		}
		else if (mode == RECORD_WAIT)
		{
			int epsilon = 5;

			delay(10);

			if (abs(vexRT[Ch3]) > epsilon || abs(vexRT[Ch1]) > epsilon)
			{
				mode = RECORDING;
				writeDebugStream("Transitioned to RECORDING mode at t = %f\n", (float) nSysTime / 1000.0);

				// Perform initial set-up for RECORDING mode.
				record_length = 0;
				nMotorEncoder[B_Drive_L] = 0;
				nMotorEncoder[C_Drive_R] = 0;
				nMotorEncoder[LIFT_TOP_LEFT] = 0;
				clearTimer(T1);
				datalogClear();
			}

			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				// Transition back to normal state (something must've gotten stuck)
				mode = NORMAL;
				writeDebugStream("Transitioned to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}
		else if (mode == RECORDING)
		{
			int effort_L = vexRT[Ch3] + vexRT[Ch1];
			int effort_R = vexRT[Ch3] - vexRT[Ch1];

			effort_L = effort_L < -127 ? -127 : (effort_L > 127 ? 127 : effort_L);
			effort_R = effort_R < -127 ? -127 : (effort_R > 127 ? 127 : effort_R);

			int effort_T = 120*(vexRT[Btn6U] ? 1 : -vexRT[Btn6D]);

			float time = ((float) time1[T1]) / 1000.0; // Current time in seconds since recording start
			signed int cumulative_position_L = nMotorEncoder[B_Drive_L]; // Current encoder pos since recording start.
			signed int cumulative_position_R = nMotorEncoder[C_Drive_R];
			signed int cumulative_position_T = nMotorEncoder[LIFT_TOP_LEFT];

			if (vexRT[Btn5U] && !_vexRT[Btn5U])
			{
				open = !open;
			}

			SensorValue[solenoid] = open;

			motor[LIFT_BOTTOM_LEFT] = effort_T;
			motor[LIFT_TOP_LEFT] = effort_T;
			motor[LIFT_BOTTOM_RIGHT] = effort_T;
			motor[LIFT_TOP_RIGHT] = effort_T;

			motor[A_Drive_LM] = effort_L;
			motor[B_Drive_L] =  effort_L;
			motor[C_Drive_R] =  effort_R;
			motor[D_Drive_RM] = effort_R;


			// Record all values into record memory.
			record_time[record_length] = time;
			L_effort[record_length] = effort_L;
			L_target[record_length] = cumulative_position_L;
			R_effort[record_length] = effort_R;
			R_target[record_length] = cumulative_position_R;
			T_effort[record_length] = effort_T;
			T_target[record_length] = cumulative_position_T;
			record_length++;

			// Record all values to the datalog.
			datalogDataGroupStart();
				datalogAddValue(0, motor[B_Drive_L]);
				datalogAddValue(1, cumulative_position_L);
				datalogAddValue(2, motor[C_Drive_R]);
				datalogAddValue(3, cumulative_position_R);
				datalogAddValue(4, motor[LIFT_TOP_LEFT]);
				datalogAddValue(5, cumulative_position_T);
			datalogDataGroupEnd();

			delay(100);

			// Transition to NORMAL mode if we fill up the record memory.
			if (record_length == MAX_RECORD_SIZE)
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			// Transition to NORMAL mode if we press D again.
			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}
		else if (mode == PLAYBACK)
		{
			float next_time = record_time[seek_index];
			float current_time = ((float) time1[T1]) / 1000.0;

			if (current_time >= next_time)
			{
				int effort_L = L_effort[seek_index];
				signed int target_L = L_target[seek_index];

				int effort_R = R_effort[seek_index];
				signed int target_R = R_target[seek_index];

				int effort_T = T_effort[seek_index];
				signed int target_T = T_target[seek_index];

				float mul = 0.5;

				effort_L += (signed char) round(mul*(target_L - nMotorEncoder[B_Drive_L]));
				effort_R += (signed char) round(mul*(target_R - nMotorEncoder[C_Drive_R]));
				effort_T += (signed char) round(mul*(target_T - nMotorEncoder[LIFT_TOP_LEFT]));

				motor[LIFT_BOTTOM_LEFT] = effort_T;
				motor[LIFT_TOP_LEFT] = effort_T;
				motor[LIFT_BOTTOM_RIGHT] = effort_T;
				motor[LIFT_TOP_RIGHT] = effort_T;

				motor[A_Drive_LM] = effort_L;
				motor[B_Drive_L] =  effort_L;
				motor[C_Drive_R] =  effort_R;
				motor[D_Drive_RM] = effort_R;

				// Record all values to the datalog.
				datalogDataGroupStart();
					datalogAddValue(0, effort_L);
					datalogAddValue(1, nMotorEncoder[B_Drive_L]);
					datalogAddValue(2, effort_R);
					datalogAddValue(3, nMotorEncoder[C_Drive_R]);
					datalogAddValue(4, effort_T);
					datalogAddValue(5, nMotorEncoder[LIFT_TOP_LEFT]);
				datalogDataGroupEnd();

				seek_index++;
			}
			else
			{
				delay(1);
			}

			// If we've read all there is to read, transition back to normal mode.
			if (seek_index >= record_length)
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			if (vexRT[Btn8R] && !_vexRT[Btn8R])
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}

		updateButtons();
	}
}
