#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  M,              sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           L,             tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           R,             tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// 60 seconds of recording, 10 records per second.
#define MAX_RECORD_SIZE 600

// Defines the exact time the values in a specific index were recorded.
// Used to match the play-back behavior in terms of recorded time, rather
// than a specific time-delta based on index.
float record_time[MAX_RECORD_SIZE];

// Defines the base effort to apply over time.
signed char L_effort[MAX_RECORD_SIZE];
signed char R_effort[MAX_RECORD_SIZE];

// Defines the cumulative encoder position targets to aim for, over time.
// Used to apply a modifier to the base effort, linearly proportional to
// the delta between the target encoder position and the current encoder.
signed int L_target[MAX_RECORD_SIZE];
signed int R_target[MAX_RECORD_SIZE];

// Defined by sizeof(vexRT)/4
#define NUM_OF_BUTTONS 22
bool _vexRT[NUM_OF_BUTTONS];

unsigned int record_length = 0;
unsigned int seek_index = 0;

enum _modeType {NORMAL, RECORD_WAIT, RECORDING, PLAYBACK};
enum _modeType mode = NORMAL;

void updateButtons()
{
	for (int i = 0; i < NUM_OF_BUTTONS; i++)
	{
		_vexRT[i] = (bool) vexRT[i];
	}
}

task main()
{
	clearDebugStream();
	writeDebugStream("Record/Playback Demo Program Start\n");

	writeDebugStream("Size of nSysTime is %d\n", sizeof(nSysTime));

	while (true)
	{
		if (mode == NORMAL)
		{
			signed char forward_channel = vexRT[Ch3];
			signed char turn_channel = -vexRT[Ch1];

			signed char effort_L = (signed char)(((float)forward_channel*1.5 + (float)turn_channel)/1.5);
			signed char effort_R = (signed char)(((float)forward_channel*1.5 - (float)turn_channel)/1.5);

			motor[L] = effort_L;
			motor[R] = effort_R;

			delay(100);

			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				// Transition to record wait state.
				mode = RECORD_WAIT;
				writeDebugStream("Transitioned to RECORD_WAIT mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			if (record_length != 0)
			{
				if (vexRT[Btn8R] && !_vexRT[Btn8R])
				{
					// Transition to playback state.
					mode = PLAYBACK;
					writeDebugStream("Transitioned to PLAYBACK mode at t = %f\n", (float) nSysTime / 1000.0);

					seek_index = 0;
					nMotorEncoder[L] = 0;
					nMotorEncoder[R] = 0;
					clearTimer(T1);
					datalogClear();
				}
			}
		}
		else if (mode == RECORD_WAIT)
		{
			int epsilon = 5;

			delay(10);

			if (abs(vexRT[Ch3]) > epsilon || abs(vexRT[Ch1]) > epsilon)
			{
				mode = RECORDING;
				writeDebugStream("Transitioned to RECORDING mode at t = %f\n", (float) nSysTime / 1000.0);

				// Perform initial set-up for RECORDING mode.
				record_length = 0;
				nMotorEncoder[L] = 0;
				nMotorEncoder[R] = 0;
				clearTimer(T1);
				datalogClear();
			}

			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				// Transition back to normal state (something must've gotten stuck)
				mode = NORMAL;
				writeDebugStream("Transitioned to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}
		else if (mode == RECORDING)
		{
			signed char forward_channel = vexRT[Ch3];
			signed char turn_channel = -vexRT[Ch1];

			signed char effort_L = (signed char)(((float)forward_channel*1.5 + (float)turn_channel)/1.5);
			signed char effort_R = (signed char)(((float)forward_channel*1.5 - (float)turn_channel)/1.5);

			float time = ((float) time1[T1]) / 1000.0; // Current time in seconds since recording start
			signed int cumulative_position_L = nMotorEncoder[L]; // Current encoder pos since recording start.
			signed int cumulative_position_R = nMotorEncoder[R];

			motor[L] = effort_L;
			motor[R] = effort_R;

			// Record all values into record memory.
			record_time[record_length] = time;
			L_effort[record_length] = effort_L;
			L_target[record_length] = cumulative_position_L;
			R_effort[record_length] = effort_R;
			R_target[record_length] = cumulative_position_R;
			record_length++;

			// Record all values to the datalog.
			datalogDataGroupStart();
				datalogAddValue(0, effort_L);
				datalogAddValue(1, cumulative_position_L);
				datalogAddValue(2, effort_R);
				datalogAddValue(3, cumulative_position_R);
			datalogDataGroupEnd();

			delay(100);

			// Transition to NORMAL mode if we fill up the record memory.
			if (record_length == MAX_RECORD_SIZE)
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			// Transition to NORMAL mode if we press D again.
			if (vexRT[Btn8D] && !_vexRT[Btn8D])
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}
		else if (mode == PLAYBACK)
		{
			float next_time = record_time[seek_index];
			float current_time = ((float) time1[T1]) / 1000.0;

			if (current_time >= next_time)
			{
				signed char effort_L = L_effort[seek_index];
				signed int target_L = L_target[seek_index];

				signed char effort_R = R_effort[seek_index];
				signed int target_R = R_target[seek_index];

				float mul = 0.5;

				effort_L += (signed char) round(mul*(target_L - nMotorEncoder[L]));
				effort_R += (signed char) round(mul*(target_R - nMotorEncoder[R]));

				motor[L] = effort_L;
				motor[R] = effort_R;

				// Record all values to the datalog.
				datalogDataGroupStart();
					datalogAddValue(0, effort_L);
					datalogAddValue(1, nMotorEncoder[L]);
					datalogAddValue(2, effort_R);
					datalogAddValue(3, nMotorEncoder[R]);
				datalogDataGroupEnd();

				seek_index++;
			}
			else
			{
				delay(1);
			}

			// If we've read all there is to read, transition back to normal mode.
			if (seek_index >= record_length)
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}

			if (vexRT[Btn8R] && !_vexRT[Btn8R])
			{
				mode = NORMAL;
				writeDebugStream("Transitioned back to NORMAL mode at t = %f\n", (float) nSysTime / 1000.0);
			}
		}

		updateButtons();
	}
}
