#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           BL,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           BR,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           FL,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           FR,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           ARM,           tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           ARMSLAVE,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ARMSLAVE2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           CLAW,          tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          LEFTCLAW,      tmotorVex269_HBridge, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "utility.c"

char buffer[64];

int arm_encoder = 0;
int claw_left_encoder = 0;
int claw_right_encoder = 0;
//Chris add 12/18/2016
int arm_encoder_up = 900;

task main()
{
	init();

	int threshold = 10;
	int X1 = 0;
	int Y1 = 0;
	int X2 = 0;

	writeDebugStreamLine("Program Start");

	while(true)
	{
		word raise_arm = vexRT[Btn6U]; // R1
		word lower_arm = vexRT[Btn6D]; // R2

		word close_claw = vexRT[Btn5U]; // L1
		word open_claw  = vexRT[Btn5D]; // L2



		if (nMotorEncoder[ARM] != arm_encoder)
		{
			arm_encoder = nMotorEncoder[ARM];
			sprintf(buffer, "Arm Encoder: %d", arm_encoder);
			//writeDebugStreamLine(buffer);
		}

		if (nMotorEncoder[CLAW] != claw_right_encoder)
		{
			claw_right_encoder = nMotorEncoder[CLAW];
			sprintf(buffer, "Right Claw Encoder: %d", claw_right_encoder);
			//writeDebugStreamLine(buffer);
		}

		if (nMotorEncoder[LEFTCLAW] != claw_left_encoder)
		{
			claw_left_encoder = nMotorEncoder[LEFTCLAW];
			sprintf(buffer, "Left Claw Encoder: %d", claw_left_encoder);
			//writeDebugStreamLine(buffer);
		}



		// Open claw
		if (open_claw)
		{
			motor[CLAW] = -40;
		}

		// Close claw
		else if (close_claw)
		{
			motor[CLAW] = 40;
		}
		else
		{
			motor[CLAW] = 0;
		}

		//Raises Arm
		if (raise_arm)
		{
			if (nMotorEncoder[ARM] >= arm_encoder_up){
			motor[ARM] = -50;
			}
			else{
			motor[ARM] = -127;
			}
		}

		//Lower Arm
		else if (lower_arm && arm_encoder > 50)
		{
			motor[ARM] = 80;
		}
		else
		{
			motor[ARM] = 0;
		}

		// Ch3: Y1
		if (abs(vexRT[Ch3]) > threshold)
		{
			Y1 = vexRT[Ch3];
		}
		else
		{
			Y1 = 0;
		}

		// Ch4: X1
		if (abs(vexRT[Ch4]) > threshold)
		{
			X1 = vexRT[Ch4];
		}
		else
		{
			X1 = 0;
		}

		// Ch1: X2
		if (abs(vexRT[Ch1]) > threshold)
		{
			X2 = vexRT[Ch1];
		}
		else
		{
			X2 = 0;
		}

		motor[FL] = -Y1 - X1 - X2;
		motor[FR] =  Y1 - X1 - X2;
		motor[BR] =  Y1 + X1 - X2;
		motor[BL] = (-Y1 + X1 - X2)*1.2;

		wait1Msec(10);
	}
}
