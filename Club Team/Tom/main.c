#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           BL,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           BR,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           FL,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           FR,            tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           ARM,           tmotorVex393HighSpeed_MC29, reversed, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           ARMSLAVE,      tmotorVex393_MC29, reversed, openLoop)
#pragma config(Motor,  port8,           ARMSLAVE2,     tmotorVex393_MC29, reversed, openLoop)
#pragma config(Motor,  port9,           CLAW,          tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          LEFTCLAW,      tmotorVex269_HBridge, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "utility.c"

// Used for printing to debug console.
char buffer[64];

//Chris add 12/18/2016
// Upper limit to induce slower movement speed and smaller arm voltage
int arm_encoder_up = 900;

int t = 0;

// Global variables for arm feedback control.
int arm_encoder = 0;
int arm_direction = 0;
int arm_encoder_target = 0;

float arm_kp = 0.35;
float arm_kp_down = 0.1;

float arm_kd = 0.2;
float arm_kd_down = 0.2;

task main()
{
	init();

	int threshold = 10;
	int X1 = 0;
	int Y1 = 0;
	int X2 = 0;

	// This will output to the console in debug mode
	writeDebugStreamLine("Program Start");

	while(true)
	{
		word raise_arm = vexRT[Btn6U]; // R1
		word lower_arm = vexRT[Btn6D]; // R2

		word close_claw = vexRT[Btn5U]; // L1
		word open_claw  = vexRT[Btn5D]; // L2

		// If the encoder value has changed
		if (-nMotorEncoder[ARM] != arm_encoder)
		{
			if (arm_encoder > -nMotorEncoder[ARM])
			{
				arm_direction = 1; // Encoder going up
			}
			else if (arm_encoder < -nMotorEncoder[ARM])
			{
				arm_direction = -1; // Encoder going down
			}

			arm_encoder = -nMotorEncoder[ARM];

			// Display the current arm encoder value on the LCD
			displayLCDPos(0,0);
			sprintf(buffer, "ARM: %d", arm_encoder);
			displayNextLCDString(buffer);

			// Display arm velocity
			int velocity = getMotorVelocity(ARM)*arm_direction;
			displayLCDPos(1,0);
			sprintf(buffer, "Vel: %d", velocity);
			displayNextLCDString(buffer);
		}


		// Open claw
		if (open_claw)
		{
			motor[CLAW] = -100;
		}

		// Close claw
		else if (close_claw)
		{
			motor[CLAW] = 40;
		}
		else
		{
			motor[CLAW] = 0;
		}


		// On input, raise or lower the target encoder value
		if (raise_arm && arm_encoder_target < 800)
		{
			arm_encoder_target += 10;
		}
		else if (lower_arm && arm_encoder_target > 0)
		{
			arm_encoder_target -= 10;
		}


		float error = arm_encoder_target - arm_encoder;
		float velocity = getMotorVelocity(ARM)*arm_direction;

		int effort = 0;


		// If arm is going down, apply the modified kp value to account for gravity.
		if (arm_encoder_target >= arm_encoder)
		{
			effort = round( error*arm_kp + velocity*arm_kd);
		}
		else if (arm_encoder_target < arm_encoder)
		{
			effort = round( error*arm_kp_down + velocity*arm_kd_down);
		}



		motor[ARM] = effort;


		/*
		if (raise_arm)
		{
			motor[ARM] = 80;
		}
		else if (lower_arm)
		{
			motor[ARM] = -20;
		}
		else
		{
			motor[ARM] = 0;
		}
		*/


		t++;

		if (t == 10)
		{
			sprintf(buffer, "Effort: %d\nTarget: %d\nError: %d\n", effort, arm_encoder_target, error);
			writeDebugStream(buffer);

			t = 0;
		}





/*
		//Raises Arm
		if (raise_arm)
		{
			if (nMotorEncoder[ARM] >= arm_encoder_up)
			{
				motor[ARM] = -50;
			}
			else
			{
				motor[ARM] = -127;
			}
		}
		//Lower Arm
		else if (lower_arm && arm_encoder > 50)
		{
			motor[ARM] = 80;
		}
		else
		{
			motor[ARM] = 0;
		}
*/
		// Ch3: Y1
		if (abs(vexRT[Ch3]) > threshold)
		{
			Y1 = vexRT[Ch3];
		}
		else
		{
			Y1 = 0;
		}

		// Ch4: X1
		if (abs(vexRT[Ch4]) > threshold)
		{
			X1 = vexRT[Ch4];
		}
		else
		{
			X1 = 0;
		}

		// Ch1: X2
		if (abs(vexRT[Ch1]) > threshold)
		{
			X2 = vexRT[Ch1];
		}
		else
		{
			X2 = 0;
		}

		// Modifier sets max speed to percentage
		// so the bot goes slower if is holding something
		float modifier = 0.5;

		if (nMotorEncoder[ARM] >= arm_encoder_up || Y1 != 0)
		{
				motor[FL] = (-Y1 - X1 - X2)*modifier;
				motor[FR] =  (Y1 - X1 - X2)*modifier;
				motor[BR] =  (Y1 + X1 - X2)*modifier;
				motor[BL] = (-Y1 + X1 - X2)*modifier;
		}
		else
		{
				motor[FL] = (-Y1 - X1 - X2);
				motor[FR] =  (Y1 - X1 - X2);
				motor[BR] =  (Y1 + X1 - X2);
				motor[BL] = (-Y1 + X1 - X2);
		}

		wait1Msec(10);
	}
}
