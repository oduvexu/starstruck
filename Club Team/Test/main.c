#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    POWER,          sensorAnalog)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LIFT,          tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define NUMBER_OF_MOTORS 5
#define MAX_BUFFER_SIZE 128

char buffer[MAX_BUFFER_SIZE];

float _motor[NUMBER_OF_MOTORS];
int _encoder[NUMBER_OF_MOTORS];

int _record[96] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 60, 60, 60, -10, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, 0, 0, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 0, -60, -60, -60, -60, -60, -60, -60, -60, 10, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, -10, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, -60, 10, 60, 60, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

void applySoftStart()
{
	for (int i = 0; i < NUMBER_OF_MOTORS; i++)
	{
		float target = _motor[i];
		int current = motor[i];

		float delta = 700; // How much it effort it changes per second

		delta = delta/10;

		// If the target and current value are further away than delta.
		if (abs(target - current) > delta)
		{
			if (target > current)
			{
				motor[i] += delta;
			}
			else
			{
				motor[i] -= delta;
			}
		}
		else
		{
			motor[i] = target;
		}

		// Gradually update encoders, but keeping possible calib sets from before.
		delta = nMotorEncoder[i] - _encoder[i];
		_encoder += delta;
	}
}

void autonomous()
{
	int wait = 100;
	int size = sizeof(_record)/4;

	for (int i = 0; i < size; i++)
	{
		motor[LIFT] = _record[i];
		wait1Msec(wait);
	}

	motor[LIFT] = 0;
}

task main()
{
	// Set soft motor array and custom encoder array to zero.
	for (int i = 0; i < NUMBER_OF_MOTORS; i++)
	{
		_motor[i] = 0;
		_encoder[i] = 0;

		nMotorEncoder[i] = 0;
	}
	clearDebugStream();

	sprintf(buffer, "Size of motor array: %d\n", sizeof(motor)/4);
	writeDebugStream(buffer);

	datalogClear();

	bool kill_timer = false;

	while (true)
	{
		if (kill_timer)
		{
			kill_timer = false;
		}
		else
		{
			kill_timer = true;
		}

		if (vexRT[Btn8D])
		{
			autonomous();
		}

		word instantaneous = vexRT[Btn5U];
		word kill = vexRT[Btn5D];

		int sensor_battery = (int)((float)SensorValue[POWER] * 3.537);

		clearDebugStream();
		sprintf(buffer, "Velocity: %d\n", getMotorVelocity(LIFT));
		writeDebugStream(buffer);

		datalogAddValue(0, getMotorVelocity(LIFT));
		datalogAddValue(1, _encoder[LIFT]);

		if (!instantaneous)
		{
			if (vexRT[Btn6U])
			{
				_motor[LIFT] = 100;
			}
			else if (vexRT[Btn6D])
			{
				_motor[LIFT] = -100;
			}
			else
			{
				_motor[LIFT] = 0;
			}
		}
		else
		{
			if (vexRT[Btn6U])
			{
				motor[LIFT] = 100;
			}
			else if (vexRT[Btn6D])
			{
				motor[LIFT] = -100;
			}
			else
			{
				motor[LIFT] = 0;
			}
		}

		if (kill)
		{
			if (kill_timer)
			{
				motor[LIFT] = -128;
			}
			else
			{
				motor[LIFT] = 128;
			}
		}

		if (!instantaneous)
		{
			applySoftStart();
		}



		wait1Msec(100);
	}
}
