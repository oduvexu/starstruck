#pragma config(Sensor, dgtl9,  pneumat,        sensorDigitalOut)
#pragma config(Motor,  port2,           Drive_LF,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Drive_LB,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Drive_RF,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Drive_RB,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LIFT_RIGHT,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LIFT_LEFT,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           CLAW_MOTOR,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define max(x, y) (((x) > (y)) ? (x) : (y))

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

void liftControl();
void driveControl();
void clawControl();
void pnematicControl();

void playRecord()
{
	clearTimer(T1);

	for (int i = 0; time1[T1] < 45*1000; i++)
	{
		//if (time1[T1] > round(_record_timeny[i]*1000.0))
		//{
		// Do this step of motor values

		//			motor[FL] = _record_FLny[i];
		//		motor[FR] = _record_FRny[i];
		//	motor[BR] = _record_BRny[i];
		//motor[BL] = _record_BLny[i];
		//motor[LIFT_BOTTOM_LEFT] = _record_ARMny[i];
		//motor[LIFT_BOTTOM_RIGHT] = _record_ARMny[i];
		//motor[LIFT_TOP_LEFT] = _record_ARMny[i];
		//motor[LIFT_TOP_RIGHT] = _record_ARMny[i];

		//SensorValue[solenoid] = _record_CLAWny[i];
		//}

		wait1Msec(1);
	}

	//Initializes the motor values to be zero after 45 seconds
	//motor[FL] = 0;
	//motor[FR] = 0;
	//motor[BR] = 0;
	//motor[BL] = 0;
	//motor[LIFT_BOTTOM_LEFT] = 0;
	//SensorValue[solenoid] = 0;
}



void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	//initiaties the function to do the autonomous
	playRecord();
}

task usercontrol()
{
	while (true)
	{
		liftControl();
		driveControl();
		clawControl();
		pnematicControl();

		clearDebugStream();
		///writeDebugStream("Solenoid: %d\n", SensorValue[solenoid]);
		/*
		//Collect the values from the Encoders to do autonomous values
		datalogDataGroupStart();
		datalogAddValue(0, motor[Drive_RF]);
		datalogAddValue(1, motor[Drive_LF]);
		datalogAddValue(2, motor[LIFT_LEFT]);
		//datalogAddValue(3, SensorValue[solenoid]);
		datalogDataGroupEnd();
		*/

		wait1Msec(100);
	}
}

/// Begin User Defined Functions

// Drive Control, channel 3 drives; channel 4 strafes
void driveControl()
{
	// Driver Control Commands Channels
	motor[Drive_RB] = (vexRT[Ch3]) + (vexRT[Ch4])*(-1);
	motor[Drive_RF] = (vexRT[Ch3]) + (vexRT[Ch4])*(-1);
	motor[Drive_LB] = (vexRT[Ch3]) + (vexRT[Ch4]);
	motor[Drive_LF] = (vexRT[Ch3]) + (vexRT[Ch4]);
}

void liftControl()//the channel 2 controls are inverted without the *(-1)
{
	int modifier = 1;
	if((vexRT[Ch2])*(-1)>0)
	{
		modifier = .85;
	}
	if((vexRT[Ch2])==0)
		{
			motor[LIFT_LEFT] = -75;
			motor[LIFT_RIGHT] = -75;
		}
	else
		{
			motor[LIFT_LEFT] = (vexRT[Ch2])*(-1)*modifier;
			motor[LIFT_RIGHT] = (vexRT[Ch2])*(-1)*modifier;
		}
}

	/*clearDebugStream();

	//Sensor code to allow tower to stop after a certain position and no damage is incurred
	if (SensorValue[killtower])
	{
		writeDebugStreamLine("Detected sensor");
	}

	if (SensorValue[killtower])
	{
		int motors[2] = {LIFT_TOP_LEFT, LIFT_TOP_RIGHT};

		for (int i = 0; i < 2; i++)
		{
			int m = motors[i];
			motor[m] = max(motor[m], 0);
		}
	}*/


void clawControl()
{
	motor[CLAW_MOTOR] = 0;
	if(vexRT[Btn5U])//the motor closes when it recieves a negative value
	{
		motor[CLAW_MOTOR] = 50;
	}
	else if(vexRT[Btn5D])
	{
		motor[CLAW_MOTOR] = -100;
	}
}

void pnematicControl()
{
	if (vexRT[Btn8U])
		SensorValue[pneumat]=1;
	else
		SensorValue[pneumat]=0;

}
