#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LEFT,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  RIGHT,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LEFT,          tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RIGHT,         tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	bool racing = false;
	bool _Btn8D = false;

	datalogClear();

	writeDebugStream("Battery: %d\n", nImmediateBatteryLevel);

	nMotorEncoder[LEFT] = 0;
	nMotorEncoder[RIGHT] = 0;

	while (true)
	{
		int forward_channel = vexRT[Ch3];
		int turn_channel = vexRT[Ch1];

		forward_channel = abs(forward_channel) <= 15 ? 0 : forward_channel;
		turn_channel = abs(turn_channel) <= 15 ? 0 : turn_channel;

		int effort_L = 0;
		int effort_R = 0;

		if (vexRT[Btn8D])
		{
			if (!_Btn8D)
			{
				// racing = !racing;
				_Btn8D = true;

				nMotorEncoder[LEFT] = 0;
				nMotorEncoder[RIGHT] = 0;
			}
		}
		else
		{
			_Btn8D = false;
		}



		if (racing)
		{
			int race_effort = 0;
			effort_L = race_effort;
			effort_R = race_effort;
		}
		else
		{
			effort_L = 0;

			int vel_L = getMotorVelocity(LEFT);
			int vel_R = getMotorVelocity(RIGHT);

			// Linearly interpolate multiplier from 1 to .1 (RPM from 0 to 150)

			float initial_mul = 1;
			float final_mul = 0.4;

			float mul_L = initial_mul - (1.0 - final_mul) * vel_L/100.0;
			float mul_R = initial_mul - (1.0 - final_mul) * vel_R/100.0;

			if (mul_L < final_mul)
			{
				mul_L = final_mul;
			}

			if (mul_R < final_mul)
			{
				mul_R = final_mul;
			}

			effort_L = (forward_channel*1.5 + turn_channel*mul_L)/1.5;
			effort_R = (forward_channel*1.5 - turn_channel*mul_R)/1.5;
		}

		if (effort_L > 0)
		{
			int max_effort = getMotorVelocity(LEFT)*50.0/150.0 + 40;
			if (effort_L > max_effort)
			{
				effort_L = max_effort;
			}
		}

		if (effort_R > 0)
		{
			int max_effort = getMotorVelocity(RIGHT)*50.0/150.0 + 40;
			if (effort_R > max_effort)
			{
				effort_R = max_effort;
			}
		}

		if (effort_R > 90)
		{
			effort_R = 90;
		}

		if (effort_L > 90)
		{
			effort_L = 90;
		}


		float initial_delta = 0;
		float final_delta = 10;

		int vel_L = getMotorVelocity(LEFT);
		int vel_R = getMotorVelocity(RIGHT);

		float delta_L = initial_delta + final_delta * vel_L/100.0;
		float delta_R = initial_delta + final_delta * vel_R/100.0;

		if (delta_L > final_delta)
		{
			delta_L = final_delta;
		}

		if (delta_R > final_delta)
		{
			delta_R = final_delta;
		}

		if (nMotorEncoder[LEFT] > nMotorEncoder[RIGHT])
		{
			effort_R += delta_R;
		}
		else if (nMotorEncoder[RIGHT] > nMotorEncoder[LEFT])
		{
			effort_L += delta_L;
		}

		if (getMotorVelocity(LEFT) > getMotorVelocity(RIGHT))
		{
			effort_R += delta_R;
		}
		else if (getMotorVelocity(RIGHT) > getMotorVelocity(LEFT))
		{
			effort_L += delta_L;
		}

		motor[LEFT] = effort_L;
		motor[RIGHT] = effort_R;

		datalogDataGroupStart();
			datalogAddValue(0, nMotorEncoder[LEFT]);
			datalogAddValue(1, nMotorEncoder[RIGHT]);
		datalogDataGroupEnd();

		wait1Msec(10);
	}
}
