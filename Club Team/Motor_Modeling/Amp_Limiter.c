#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           TEST,          tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           TEST2,         tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Amp_Limiter_Func.c"


task one;
task two;


task main()
{

init_SmartMotor(motorS[0], TEST, 2);
init_SmartMotor(motorS[1], TEST2, 3);

group_SmartMotor(0,motorS[0]);
group_SmartMotor(0,motorS[1]);


groupAmpsLimit[0] = 4;

monitorGroup[0] = true;

motorS[0].targetAmp = 2;
motorS[1].targetAmp = 2;

startTask(one);
startTask(two);


while(1){




int forward_channel = abs(vexRT[Ch3]) <= 15 ? 0 : vexRT[Ch3];
int turn_channel = abs(vexRT[Ch1]) <= 15 ? 0 : vexRT[Ch1];



motor[TEST] = (forward_channel*1.5 + turn_channel*0.4)/2 - motorS[0].deltaEffort;
motor[TEST2] = (forward_channel*1.5 - turn_channel*0.4)/2 - abs(motorS[0].deltaEffort)*motorS[1].direction;



clearDebugStream();
writeDebugStream("A Effort:%d\n",motorS[0].effort);
writeDebugStream("A Effort Delta:%d\n",motorS[0].deltaEffort);
writeDebugStream("B Effort:%d\n",motorS[1].effort);
writeDebugStream("B Effort Delta:%d\n",motorS[1].deltaEffort);
writeDebugStream("A GroupA:%f\n",groupAmps[0]);
writeDebugStream("A GroupB:%f\n",groups[0][1]);
writeDebugStream("BackEMF:%f\n",motorS[0].backEMF);
writeDebugStream("Amp:%f\n",motorS[0].amps);

wait1Msec(10);

}

}

task one{
start_SmartMotor(motorS[0]);
}

task two{
start_SmartMotor(motorS[1]);
}
