#pragma config(Sensor, dgtl11, solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl12, killtower,      sensorTouch)
#pragma config(Motor,  port2,  LIFT_BOTTOM_RIGHT, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,  LIFT_TOP_RIGHT, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,  A_Drive_LM,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,  B_Drive_L,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,  C_Drive_R,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,  D_Drive_RM,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,  LIFT_TOP_LEFT, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,  LIFT_BOTTOM_LEFT, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define max(x, y) (((x) > (y)) ? (x) : (y))

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"


void liftControl();
void driveControl();
void clawControl();

bool open = false;
bool prev_btn = false;

void playRecord()
{
	int i = 0;

	clearTimer(T1);

	while (time1[T1] < 45*1000)
	{
		//if (time1[T1] > round(_record_timeny[i]*1000.0))
		//{
			// Do this step of motor values

//			motor[FL] = _record_FLny[i];
	//		motor[FR] = _record_FRny[i];
		//	motor[BR] = _record_BRny[i];
			//motor[BL] = _record_BLny[i];
			//motor[LIFT_BOTTOM_LEFT] = _record_ARMny[i];
			//motor[LIFT_BOTTOM_RIGHT] = _record_ARMny[i];
			//motor[LIFT_TOP_LEFT] = _record_ARMny[i];
			//motor[LIFT_TOP_RIGHT] = _record_ARMny[i];

			//SensorValue[solenoid] = _record_CLAWny[i];

		//	i++;
		//}

		wait1Msec(1);
	}

	//Initializes the motor values to be zero after 45 seconds
	//motor[FL] = 0;
	//motor[FR] = 0;
	//motor[BR] = 0;
	//motor[BL] = 0;
	//motor[LIFT_BOTTOM_LEFT] = 0;
	//SensorValue[solenoid] = 0;
}



void pre_auton()
{
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	//initiaties the function to do the autonomous
	playRecord();
}

task usercontrol()
{
	while (true)
	{
		liftControl();
		driveControl();
		clawControl();

		clearDebugStream();
		writeDebugStream("Solenoid: %d\n", SensorValue[solenoid]);

		//Collect the values from the Encoders to do autonomous values
		datalogDataGroupStart();
		datalogAddValue(0, motor[C_Drive_R]);
		datalogAddValue(1, motor[B_Drive_L]);
		datalogAddValue(2, motor[LIFT_TOP_LEFT]);
		//datalogAddValue(3, SensorValue[solenoid]);
		datalogDataGroupEnd();

		wait1Msec(100);
	}
}

/// Begin User Defined Functions

// Drive Control, channel 1 rotates; channel 3 drives; channel 4 strafes
void driveControl()
{

	// Driver Control Commands Channels
		motor[D_Drive_RM] = (vexRT[Ch3]) + (vexRT[Ch4])*(-1);
		motor[C_Drive_R]  = (vexRT[Ch3]) + (vexRT[Ch4])*(-1);
		motor[A_Drive_LM]   = (vexRT[Ch3]) + (vexRT[Ch4]);
		motor[B_Drive_L]  = (vexRT[Ch3]) + (vexRT[Ch4]);

}

void liftControl() {

	if (vexRT[Btn6U])
	{
		//Activates Tower to raise when Button 6-U is pressed
		int effort = 120;
		motor[LIFT_BOTTOM_LEFT] = effort;
		motor[LIFT_TOP_LEFT] = effort;
		motor[LIFT_BOTTOM_RIGHT] = effort;
		motor[LIFT_TOP_RIGHT] = effort;
	}
	else if (vexRT[Btn6D])
	{
		//Activates Tower to lower when button 6-D is pressed
		int effort = -120;
		motor[LIFT_BOTTOM_LEFT] = effort;
		motor[LIFT_TOP_LEFT] = effort;
		motor[LIFT_BOTTOM_RIGHT] = effort;
		motor[LIFT_TOP_RIGHT] = effort;
	}
	else
	{
		//Allows for the Tower to stop and maintian position
		int effort = 0;
		motor[LIFT_BOTTOM_LEFT] = effort;
		motor[LIFT_TOP_LEFT] = effort;
		motor[LIFT_BOTTOM_RIGHT] = effort;
		motor[LIFT_TOP_RIGHT] = effort;
	}

	clearDebugStream();

	//Sensor code to allow tower to stop after a certain position and no damage is incurred
	if (SensorValue[killtower])
	{
		writeDebugStreamLine("Detected sensor");
	}

	if (SensorValue[killtower])
	{
		int motors[4] = {LIFT_BOTTOM_LEFT, LIFT_TOP_LEFT, LIFT_BOTTOM_RIGHT, LIFT_TOP_RIGHT};

		for (int i = 0; i < 4; i++)
		{
			int m = motors[i];
			motor[m] = max(motor[m], 0);
		}
	}

}

void clawControl()
{
	if (vexRT[Btn5U] && !prev_btn)
	{
		//Allows for the Claw to maintian position up when not initiatied
		open = !open;
	}

	if(open)
	{
		//Allows for the Claw to open when button 5-U is pressed
		SensorValue[solenoid] = 1;
	}

	else
	{
		//Allows for the Claw to close when button 5-U is pressed again
		SensorValue[solenoid] = 0;
	}

	prev_btn = (bool) vexRT[Btn5U];
}
